[{"content":"安装过程 首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo可以直接用Winget来安装，打开终端输入\nwinget install Hugo.Hugo.Extended 如果提示not recognized as the name of cmdlet，查找C:\\Users\\Username\\AppData\\Local\\Microsoft\\WindowsApps目录下有没有winget.exe，如果存在则添加这个目录到环境变量，否则去应用商店找winget，这是windows官方提供的windows包管理工具，一般系统里都会自带。\nHugo的tutorial介绍了如何创建一个项目，其中step2（.yml的config文件）和step3（下载主题）要根据PaperMod的guide来配置。\n文件介绍 content：用于放博客内容 data：不用管 layouts：自定义的HTML public：项目导出文件 resources：自定义的CSS和JavaScript static：存放的图片 themes：主题 进入themes/PaperMod则是PaperMod的相关代码，比较主要的目录有：\nassets：PaperMod的CSS和JavaScript代码 layouts：PaperMod的HTML Config.yml 建议直接按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n创建文章 在终端输入hugo new 文章名称.md就会在content文件夹下创建markdown文件，文章头部信息可以修改这篇文章的属性，建议按照【置顶】hugo博客搭建 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)进行配置。\n本地预览 在终端输入hugo server -D启动，建议新建一个.bat文件执行这条指令。 启动服务器后，打开浏览器，本地预览网址为localhost:1313。 网站部署 我用的是GitHub Page。\n在GitHub里创建一个仓库，名称叫做你的名字.github.io。 当我们本地预览没问题了的时候，在终端输入hugo -F --cleanDestinationDir，在public文件夹下就会生成输出文件。 我们将public文件夹作为GitHub Page的本地仓库，每次生成输出文件就推送到GitHub上，GitHub Page就会自动帮我们部署了。 多语言 如果我们想要使用多语言（中英为例），就需要在content文件夹下准备两个文件夹，例如Chinese和English，一个放中文，另一个放英文。 在config.yml中需要做以下修改： defaultContentLanguage: en defaultContentLanguageInSubdir: true languages: en: languageName: \u0026#34;English\u0026#34; contentDir: content/English zh: languageName: \u0026#34;中文\u0026#34; contentDir: content/Chinese 搜索功能 分别在中英文的文件夹下创建search.md（hugo new search.md），修改文件头为： title: \u0026#34;Search\u0026#34; date: ... draft: false layout: search config.yml中添加： menu: main: -identifier: Search name: Search url: search weight: ... Hover 主要在themes/PaperMod/assets/css/common/header.css中修改。\n左上角Home的hover： .logo a:hover { transition: 0.15s; color: grey; } 社交媒体hover： svg:hover { transition: 0.15s; } .social-icons a:nth-child(1) svg:hover{ color: #C84370 !important; } .social-icons a:nth-child(2) svg:hover { color: grey !important; } ... nth-child可以设置各个图标的hover颜色。\n黑夜模式和白天模式的hover： #moon:hover { transition: 0.15s; color: deepskyblue; } #sun:hover { transition: 0.15s; color: gold; } menu中链接hover： #menu a:hover { transition: 0.15s; color: grey; } 按钮hover： 在themes/PaperMod/assets/css/common/profile-mode.css中修改：\n.button:hover { -webkit-transform: scale(1.1); -moz-transform: scale(1.1); -ms-transform: scale(1.1); -o-transform: scale(1.1); /* box-shadow: 0 0 0 1px grey; */ transform: scale(1.1) translateZ(0) translate3d(0, 0, 0) rotate(0.01deg); } 自定义社交媒体图标 利用SVG图标制作网站，比如icons8，找到我们需要的图标，例如微信。 可以利用左侧菜单栏的Stroke调节线条粗细。 点击download，SVG Embed，自定义图标大小为24*24，然后点击copy HTML。 在themes/PaperMod/layouts/partials/svg.html中粘贴复制的HTML。 需要修改为fill=currentColor stroke=currentColor，才能适应白天黑夜切换。 微信和微博的图标： {{- else if (eq $icon_name \u0026#34;wechat\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 50 50\u0026#34;\u0026gt; \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M 19 6 C 9.746094 6 2 12.359375 2 20.5 C 2 24.894531 4.292969 28.679688 7.835938 31.324219 L 5.179688 39.304688 L 13.472656 34.167969 C 15.1875 34.707031 17.082031 35 19 35 C 19.746094 35 20.472656 34.945313 21.195313 34.863281 C 23.378906 39.105469 28.328125 42 34 42 C 35.722656 42 37.316406 41.675781 38.796875 41.234375 L 45.644531 45.066406 L 43.734375 38.515625 C 46.3125 36.375 48 33.394531 48 30 C 48 23.789063 42.597656 18.835938 35.75 18.105469 C 34.398438 11.125 27.324219 6 19 6 Z M 19 8 C 26.308594 8 32.328125 12.351563 33.703125 18.011719 C 26.183594 18.148438 20 23.355469 20 30 C 20 31.019531 20.160156 32.003906 20.4375 32.941406 C 19.964844 32.980469 19.484375 33 19 33 C 17.101563 33 15.199219 32.710938 13.632813 32.15625 L 13.183594 32 L 8.820313 34.699219 L 10.1875 30.59375 L 9.5625 30.171875 C 6.082031 27.820313 4 24.445313 4 20.5 C 4 13.640625 10.65625 8 19 8 Z M 13 14 C 11.898438 14 11 14.898438 11 16 C 11 17.101563 11.898438 18 13 18 C 14.101563 18 15 17.101563 15 16 C 15 14.898438 14.101563 14 13 14 Z M 25 14 C 23.898438 14 23 14.898438 23 16 C 23 17.101563 23.898438 18 25 18 C 26.101563 18 27 17.101563 27 16 C 27 14.898438 26.101563 14 25 14 Z M 34 20 C 40.746094 20 46 24.535156 46 30 C 46 32.957031 44.492188 35.550781 42.003906 37.394531 L 41.445313 37.8125 L 42.355469 40.933594 L 39.105469 39.109375 L 38.683594 39.25 C 37.285156 39.71875 35.6875 40 34 40 C 27.253906 40 22 35.464844 22 30 C 22 24.535156 27.253906 20 34 20 Z M 29.5 26 C 28.699219 26 28 26.699219 28 27.5 C 28 28.300781 28.699219 29 29.5 29 C 30.300781 29 31 28.300781 31 27.5 C 31 26.699219 30.300781 26 29.5 26 Z M 38.5 26 C 37.699219 26 37 26.699219 37 27.5 C 37 28.300781 37.699219 29 38.5 29 C 39.300781 29 40 28.300781 40 27.5 C 40 26.699219 39.300781 26 38.5 26 Z\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;/svg\u0026gt; {{- else if (eq $icon_name \u0026#34;weibo\u0026#34;) -}} \u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; x=\u0026#34;0px\u0026#34; y=\u0026#34;0px\u0026#34; width=\u0026#34;24\u0026#34; height=\u0026#34;24\u0026#34; viewBox=\u0026#34;0 0 172 172\u0026#34;\u0026gt; \u0026lt;g fill=\u0026#34;currentColor\u0026#34; stroke=\u0026#34;currentColor\u0026#34; stroke-width=\u0026#34;4\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M120.4,20.64c-2.67406,0 -5.25406,0.26875 -7.74,0.71219c-1.86781,0.3225 -3.1175,2.10969 -2.795,3.9775c0.3225,1.88125 2.10969,3.13094 3.9775,2.80844c2.17688,-0.38969 4.35375,-0.61813 6.5575,-0.61813c20.93563,0 37.84,16.90438 37.84,37.84c0,4.52844 -0.83312,8.85531 -2.31125,12.91344c-0.45687,1.16906 -0.25531,2.48594 0.5375,3.45344c0.80625,0.9675 2.05594,1.42437 3.29219,1.19594c1.23625,-0.22844 2.24406,-1.11531 2.63375,-2.29781c1.73344,-4.75687 2.72781,-9.87656 2.72781,-15.265c0,-24.65781 -20.06219,-44.72 -44.72,-44.72zM120.4,41.28c-1.46469,0 -2.84875,0.14781 -4.16562,0.37625c-1.86781,0.33594 -3.13094,2.10969 -2.795,3.99094c0.3225,1.86781 2.10969,3.1175 3.9775,2.795c1.00781,-0.17469 2.00219,-0.28219 2.98312,-0.28219c9.54063,0 17.2,7.65938 17.2,17.2c0,2.05594 -0.37625,4.01781 -1.06156,5.87219c-0.645,1.78719 0.28219,3.7625 2.06938,4.4075c1.78719,0.645 3.7625,-0.26875 4.4075,-2.05594c0.92719,-2.55312 1.46469,-5.32125 1.46469,-8.22375c0,-13.26281 -10.81719,-24.08 -24.08,-24.08zM72.46844,42.6775c-11.04562,0 -27.50656,8.66719 -42.18031,23.07219c-14.76781,14.76781 -23.40813,30.24781 -23.40813,43.57781c0,25.9075 33.12344,41.3875 65.88406,41.3875c42.47594,0 70.90969,-24.46969 70.90969,-43.91375c0,-11.87875 -10.07812,-18.35562 -19.08125,-21.23125c-2.15,-0.72562 -3.60125,-1.08844 -2.52625,-3.96406c0.72563,-1.73344 1.77375,-5.01219 1.77375,-9.36594c0,-4.945 -3.44,-9.23156 -10.32,-9.9975c-0.79281,-0.08062 -2.13656,-0.14781 -3.82969,-0.14781c-5.6975,0 -15.48,0.71219 -22.52125,3.66844c0,0 -1.38406,0.57781 -2.49938,0.57781c-1.00781,0 -1.80062,-0.48375 -1.11531,-2.37844c2.52625,-7.91469 2.16344,-14.39156 -1.80063,-18.00625c-2.23062,-2.23062 -5.42875,-3.27875 -9.28531,-3.27875zM72.46844,49.5575c1.43781,0 3.37281,0.215 4.43438,1.26313l0.1075,0.12094l0.12094,0.1075c1.54531,1.41094 1.51844,5.61687 -0.09406,10.72312c-1.38406,3.99094 -0.09406,6.75906 0.81969,8.04906c1.51844,2.16344 4.00437,3.39969 6.81281,3.39969c2.28438,0 4.39406,-0.79281 5.14656,-1.11531c5.50938,-2.31125 13.88094,-3.13094 19.87406,-3.13094c1.53187,0 2.60687,0.05375 3.07719,0.1075c2.78156,0.30906 4.1925,1.37063 4.1925,3.15781c0,3.23844 -0.77937,5.61688 -1.23625,6.73219l-0.05375,0.1075l-0.04031,0.09406c-1.075,2.88906 -1.06156,5.50938 0.04031,7.80719c1.62594,3.39969 4.82406,4.46125 6.54406,5.03906l0.28219,0.09406c5.34813,1.70656 14.2975,5.88562 14.2975,14.68719c0,7.90125 -6.81281,17.65688 -18.90656,25.16844c4.77031,-5.54969 7.47125,-12.05344 7.47125,-19.05437c0,-21.01625 -24.37562,-37.47719 -55.48344,-37.47719c-31.10781,0 -55.47,16.46094 -55.47,37.47719c0,0.645 0.01344,1.27656 0.05375,1.90812c-0.45687,-1.76031 -0.69875,-3.60125 -0.69875,-5.49594c0,-11.16656 7.59219,-24.91312 21.33875,-38.65969c14.86188,-14.59313 29.48188,-21.11031 37.36969,-21.11031zM69.875,82.33156c26.84813,0 48.60344,13.69281 48.60344,30.59719c0,16.89094 -21.75531,30.58375 -48.60344,30.58375c-26.83469,0 -48.59,-13.69281 -48.59,-30.58375c0,-16.90437 21.75531,-30.59719 48.59,-30.59719zM66.27375,89.52063c-10.38719,0.08062 -20.47875,5.76469 -24.85937,14.52594c-5.40188,11.13969 -0.36281,23.38125 12.59094,27.33187c12.95375,4.31344 28.42031,-2.16344 33.82219,-14.02875c5.38844,-11.5025 -1.43781,-23.73062 -14.39156,-26.95562c-2.365,-0.61813 -4.77031,-0.88688 -7.16219,-0.87344zM71.63531,104.06c1.98875,0 3.60125,1.59906 3.60125,3.58781c0,1.98875 -1.6125,3.60125 -3.60125,3.60125c-1.98875,0 -3.60125,-1.6125 -3.60125,-3.60125c0,-1.98875 1.6125,-3.58781 3.60125,-3.58781zM56.47781,107.64781c1.12875,0.01344 2.2575,0.18812 3.31906,0.55094c4.60906,1.46469 6.02,5.83188 3.18469,9.47344c-2.4725,3.64156 -8.12969,5.45563 -12.38938,3.64156c-4.23281,-1.81406 -5.29437,-6.19469 -2.82187,-9.46c1.85437,-2.74125 5.30781,-4.24625 8.7075,-4.20594z\u0026#34;\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/g\u0026gt; \u0026lt;path d=\u0026#34;\u0026#34; fill=\u0026#34;none\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; 目录栏目放侧边 详见：Hugo博客目录放在侧边 | PaperMod主题 | Sulv\u0026rsquo;s Blog (sulvblog.cn)。\nMarkdown渲染风格 详见：折腾 Hugo \u0026amp; PaperMod 主题 - Dvel\u0026rsquo;s Blog\n流量统计 这里我使用了不蒜子，在themes/PaperMod/layouts/partials/svg.html中修改：\n{{- if not (.Param \u0026#34;hideFooter\u0026#34;) }} \u0026lt;footer class=\u0026#34;footer\u0026#34;\u0026gt; {{- if site.Copyright }} ... {{- end }} \u0026lt;script async src=\u0026#34;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;span id=\u0026#34;busuanzi_container\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css\u0026#34;\u0026gt; Visitors: \u0026lt;span id=\u0026#34;busuanzi_value_site_uv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; Views: \u0026lt;span id=\u0026#34;busuanzi_value_site_pv\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;/footer\u0026gt; {{- end }} 插入B站，YouTube视频或PPT 详见：Hugo博客自定义shortcodes | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n插入音乐播放器 详见：Hugo插入音乐播放器\n隐藏歌词：lrc-type=0\n修改全局字体 首先找到喜欢的字体，然后可以在Google Fonts中查询字体，我目前的文章字体为CodeNewRoman。Google Fonts会生成HTML和css，将HTML插入到themes/PaperMod/layouts/partials/extend_head.html中，将CSS插入到themes/PaperMod/assets/css/extended/blank.css。\nbody { font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif; font-size: 1rem; line-height: 1.5; margin: 0; } 修改代码字体 与全局字体类似，区别为CSS代码插入的位置不同。\n.post-content pre, code { font-family: \u0026#39;Code New Roman\u0026#39;, sans-serif; max-height: 40rem; } 评论功能 详见：Hugo博客添加Twikoo评论 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\nGmail邮箱配置 登录 Google Account，进入Security / Signing in to Google / 2-Step Verification / App passwords。点击Generate，并记住这个16位的密码。\n在Twikoo中进行配置：\nSENDER_EMAIL：你的gmail邮箱\nSENDER_NAME：发件人名，我写的是Notification from Kunyang\u0026rsquo;s Blog\nSMTP_SERVICE：Gmail\nSMTP_HOST：smtp.gmail.com\nSMTP_PORT：587\nSMTP_SECURE：true\nSMTP_USER：你的gmail邮箱\nSMTP_PASS：16位的应用密码\nSMTP_SUBJECT：邮件主题，我写的是You have received a response from Kunyang\u0026rsquo;s Blog\nMAIL_TEMPLATE：邮件模板，我的是：\n\u0026lt;div style=\u0026#34;border-top:2px solid #12ADDB;box-shadow:0 1px 3px #AAAAAA;line-height:180%;padding:0 15px 12px;margin:50px auto;font-size:12px;\u0026#34;\u0026gt; \u0026lt;h2 style=\u0026#34;border-bottom:1px solid #dddddd;font-size:14px;font-weight:normal;padding:13px 0 10px 8px;\u0026#34;\u0026gt; You have received a new response from \u0026lt;a style=\u0026#34;text-decoration:none;color:#12ADDB;\u0026#34; href=\u0026#34;https://ymz-1.github.io/\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;Kunyang\u0026#39;s Blog\u0026lt;/a\u0026gt; \u0026lt;/h2\u0026gt; ${PARENT_NICK} Your comment: \u0026lt;div style=\u0026#34;padding:0 12px 0 12px;margin-top:18px\u0026#34;\u0026gt; \u0026lt;div style=\u0026#34;background-color:#f5f5f5;padding:10px 15px;margin:18px 0;word-wrap:break-word;\u0026#34;\u0026gt; ${PARENT_COMMENT} \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; \u0026lt;strong\u0026gt;${NICK}\u0026lt;/strong\u0026gt; says: \u0026lt;/p\u0026gt; \u0026lt;div style=\u0026#34;background-color:#f5f5f5;padding:10px 15px;margin:18px 0;word-wrap:break-word;\u0026#34;\u0026gt; ${COMMENT} \u0026lt;/div\u0026gt; \u0026lt;p\u0026gt; Click \u0026lt;a style=\u0026#34;text-decoration:none;color:#12ADDB;\u0026#34; href=\u0026#34;${POST_URL}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;to view the reply\u0026lt;/a\u0026gt;, welcome to \u0026lt;a style=\u0026#34;text-decoration:none;color:#12ADDB;\u0026#34; href=\u0026#34;${SITE_URL}\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;${SITE_NAME}\u0026lt;/a\u0026gt;。\u0026lt;br\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 配置完成后评论消息就会有gmail邮箱发送的邮件提醒了，outlook邮箱配置见：关于邮箱配置的问题？ · twikoojs/twikoo · Discussion #249 (github.com)。\n自定义邮箱回复模板 详见：自定义Twikoo邮件通知模板 | Guo Le\u0026rsquo;s Blog\n代码高亮 在两个地方修改\n一个是themes/PaperMod/assets/css/common/post-single.css：\n.post-content pre code { display: block; margin: auto 0; padding: 10px; /* 主要代码颜色 */ color: #abb2bf; font-weight: 200; overflow-x: auto; word-break: break-all; } 另一个是在themes/PaperMod/assets/css/hljs/an-old-hope.min.css，这是我自己修改的：\n/* 注释 */ .hljs-comment, .hljs-quote { font-weight: 200; color: #7f848e; } .hljs-deletion, /* html标签 */ .hljs-name, .hljs-regexp, .hljs-tag { font-weight: 200; color: #e06c75; } /* html属性 */ .hljs-tag { font-weight: 200; color: #d19a66; } /* css类名 */ .hljs-template-variable, .hljs-variable, .hljs-selector-class, .hljs-selector-id { font-weight: 200; color: #a9b600; } /* 内置函数 */ .hljs-built_in, .hljs-builtin-name { font-weight: 200; color: #56b6c2; } /* 函数输入 */ .hljs-params { font-weight: 200; color: #e5c07b; } /* 数字 */ .hljs-number { font-weight: 200; color: #d19a66; } /* css属性 */ .hljs-attribute { font-weight: 200; color: #ee7c2b; } /* 字符串 */ .hljs-addition, .hljs-bullet, .hljs-symbol, .hljs-string { font-weight: 200; color: #98c379; } /* 函数名称 */ .hljs-section, .hljs-title { font-weight: 200; color: #56b6c2; } /* 关键字 */ .hljs-keyword, .hljs-selector-tag, .hljs-literal, .hljs-link, .hljs-meta, .hljs-type { font-weight: 200; color: #c678dd; } .hljs { display: block; overflow-x: auto; background: #1c1d21; color: #c0c5ce; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: 700; } /* 选中时的背景颜色 */ .hljs ::selection, .hljs::selection { background-color: #3d4556; } 代码边框圆角 themes/PaperMod/assets/css/common/post-single.css中修改：\n.post-content .highlight pre { background-color: var(--theme) !important; margin: 0; } 添加友链 详见：Hugo博客添加友链 | Sulv\u0026rsquo;s Blog (sulvblog.cn)\n","permalink":"https://ymz-1.github.io/zh/blog/tech/papermod/","summary":"安装过程 首先需要安装Hugo，安装Hugo需要利用一个包管理工具，对于Windows系统Hugo可以直接用Winget来安装，打开终端输入 winget","title":"Hugo + PaperMod搭建技术博客"},{"content":"Server 下载OpenVPN\nsudo apt-get install openvpn 在/usr/share/doc/openvpn/examples/sample-keys/文件夹下有好多keys，在server中，复制ca.crt，server.key，server.crt，dh2048.pem到/etc/openvpn/server\nsudo cp /usr/share/doc/openvpn/examples/sample-keys/{ca.crt,server.key,server.crt,dh2048.pem} /etc/openvpn/server 编写服务器配置文件\nport 1194 proto udp dev tun ca ca.crt cert server.crt key server.key dh dh2048.pem server 10.8.0.0 255.255.255.0 keepalive 10 120 user nobody group nogroup persist-key persist-tun verb 3 启动OpenVPN Server\ncd /etc/openvpn/server sudo openvpn --config server.conf 这时如果查看ip地址可以看到tun0接口，地址是10.8.0.1\nClient 下载OpenVPN\nsudo apt-get install openvpn 从Server上复制对应的ca.crt，client.crt，client.key\nsudo scp username@address:/usr/share/doc/openvpn/examples/sample-keys/{ca.crt,client.crt,client.key} /etc/openvpn/client 编写client.conf\nclient dev tun proto udp remote SERVER_ADDR 1194 ca ca.crt cert client.crt key client.key user nobody group nogroup persist-key persist-tun verb 3 启动OpenVPN Client\ncd /etc/openvpn/client sudo openvpn --config client.conf 这时如果执行\nping 10.8.0.1 成功，说明OpenVPN成功建立\n","permalink":"https://ymz-1.github.io/zh/blog/tech/openvpn/","summary":"Server 下载OpenVPN sudo apt-get install openvpn 在/usr/share/doc/openvpn/examples/sample-keys/文件夹下有好多keys","title":"Linux配置OpenVPN"},{"content":"通过使用keys我们可以免密登录Linux server，这样以后ssh到Linux的时候就不需要每次填写密码了。\n首先在windows上生成一个密钥对，一般会生成在C:\\Users\\Username/.ssh/id_rsa，而且都是成对生成的，会有一个公钥id_rsa.pub和一个私钥。\nssh-keygen 在Linux中查看是否有.ssh目录，如果没有则新建\ncd ~ mkdir -p ~/.ssh chmod 700 ~/.ssh 将公钥id_rsa.pub上传到Linux\ncd C:\\Users\\Username/.ssh/ scp .\\id_rsa.pub username@address:~/.ssh 在Linux中查看是否有authorized_keys文件，如果没有则新建\ncd ~/.ssh touch authorized_keys chmod 600 ./authorized_keys cat id_rsa.pub \u0026gt;\u0026gt; ./authorized_keys 添加完之后就可以将id_rsa.pub删除了\ncd ~/.ssh rm id_rsa.pub 这样以后就不再需要输密码了。\n","permalink":"https://ymz-1.github.io/zh/blog/tech/keys/","summary":"通过使用keys我们可以免密登录Linux server，这样以后ssh到Linux的时候就不需要每次填写密码了。 首先在windows上生成一","title":"使用Keys免密SSH到Linux"},{"content":"Linux 下载OpenLDAP：\nsudo apt update sudo apt install slapd ldap-utils sudo apt install ldap-utils 配置OpenLDAP：\nsudo dpkg-reconfigure slapd DNS domain name: example.org\nPassword: root\n创建user.ldif：\n# ldap是username dn: uid=ldap,dc=example,dc=org objectClass: inetOrgPerson objectClass: posixAccount uid: ldap sn: LDAP givenName: LDAP cn: LDAP User displayName: LDAP User uidNumber: 10000 gidNumber: 10000 homeDirectory: /home/ldap loginShell: /bin/bash 把user加入OpenLDAP服务器：\nldapadd -x -D \u0026#34;cn=admin,dc=example,dc=org\u0026#34; -W -f user.ldif 启动和查看OpenLDAP的状态：\nsudo systemctl start slapd sudo systemctl status slapd 查看当前已有的用户：\nldapsearch -x -LLL -b \u0026#34;dc=example,dc=org\u0026#34; \u0026#34;(objectclass=inetOrgPerson)\u0026#34; uid userPassword 修改用户密码：\nldappasswd -x -D \u0026#34;cn=admin,dc=example,dc=org\u0026#34; -W -S \u0026#34;uid=ldap,dc=example,dc=org\u0026#34; ","permalink":"https://ymz-1.github.io/zh/blog/tech/ldap/","summary":"Linux 下载OpenLDAP： sudo apt update sudo apt install slapd ldap-utils sudo apt install ldap-utils 配置OpenLDAP： sudo dpkg-reconfigure slapd DNS domain name: example.org Password: root 创建user.ldif： # ldap是username","title":"搭建LDAP Server"},{"content":"前言 我比较喜欢在虚拟机上来搭建环境，但是有些软件（比如一些数据库可视化软件）在Linux是上是没有的，于是想了个办法将Linux映射为Windows的一个本地磁盘，这样Windows的软件就可以直接打开Linux的文件夹了。\nLinux 假如我现在登录用户为user1，我希望把home/user1的所有文件共享给Windows，当然也可以新建用户和新建文件夹来作为共享文件夹。\n安装Samba：\nsudo apt update sudo apt install samba 编辑Samba配置文件：\nsudo nano /etc/samba/smb.conf 在文本末尾添加：\n[Name] path = /home/user1/shared read only = no browsable = yes [Name]是共享文件夹的名称，会显示在Windows磁盘上\n设置Samba账户密码：\nsudo smbpasswd -a user1 sudo smbpasswd -e user1 重启Samba服务：\nsudo systemctl restart smbd Windows 打开文件资源管理器 右键点击“此电脑”，选择“映射网络驱动器” 选择一个驱动器字母（例如Z:） 在文件夹栏中输入：\\\\Linux IP Address\\Name 完成剩余步骤 ","permalink":"https://ymz-1.github.io/zh/blog/tech/samba/","summary":"前言 我比较喜欢在虚拟机上来搭建环境，但是有些软件（比如一些数据库可视化软件）在Linux是上是没有的，于是想了个办法将Linux映射为Win","title":"使用Samba将Linux映射为Windows磁盘"},{"content":"前言 我就喜欢搞一些简洁而又花里胡哨的东西。\n教程基于Windows 11自带的Terminal。\n字体 我使用的字体是CodeNewRoman Nerd Font，这个字体同样是我博客的字体，可以从这里下载，下载后安装即可，也可以在VS Code上使用这个字体。\n下载 oh-my-posh winget install JanDeDobbeleer.OhMyPosh 终端设置 我这里直接修改了Windows PowerShell的配置，如果不想破坏默认的配置也可以新建一个配置文件。\n在配色方案的选项下，我选择的Campbell，但是我打开设置的json file里面把第一个主题的background改成了#0C0C0C，避免了纯黑的背景。\n在Windows PowerShell的常规选项下，取消勾选使用父进程目录，在外观选项下选取下载的字体CodeNowRoman Nerd Font。\n文件配置 在终端输入\necho $profile 找到这个文件，如果找不到自己新建一个。\n从这里选择一个自己喜欢的主题，点击主题名字进入相应的github并且下载.json源码，保存在本地，粘贴下面语句到这个文件中，修改路径为你保存的路径。\noh-my-posh init pwsh --config \u0026#39;C:/Users/Posh/jandedobbeleer.omp.json\u0026#39; | Invoke-Expression 保存后运行：\n. $profile FAQ 如果运行失败，可能需要更新PSReadLine。\n如果识别不了icon，大概率字体的问题，查看是否在PowerShell的页面下设置字体为Nerd字体。\n效果展示 ","permalink":"https://ymz-1.github.io/zh/blog/tech/bash/","summary":"前言 我就喜欢搞一些简洁而又花里胡哨的东西。 教程基于Windows 11自带的Terminal。 字体 我使用的字体是CodeNewRoman Nerd Fo","title":"Windows 11 打造个性化终端"},{"content":"Character 判断是否为字母或数字：\nboolean res = Character.isLetterOrDigit(char); 转小写：\nchar res = Character.toLowerCase(char); 下一个字符：\n\u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值：\nint max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等：\nInteger a = 1; Integer b = 1; a == b;\t// true Integer c = 200; Integer d = 200; c == d;\t// false Objects.equals(c, d);\t// true Array 创建数组：\nint[] array = new int[5]; int[] array = new int[]{1,2,3,4}; int[] array = {1,2,3,4}; int[][] array = {{1,2}, {3,4}}; 引用：\narray[3]; 获取长度：\narray.length; 排序：\nArrays.sort(array); // int[] 不能直接做降序排列 // 想做降序排列只能用Integer[] Integer[] array = new Integer[2]; Arrays.sort(array, Comparitor.naturalOrder());\t// 升序排列 Arrays.sort(array, Comparator.reverseOrder());\t// 降序排列 二维数组排序：\nint[][] array = new int[][]{{1, 2}, {2, 3}}; Arrays.sort(array, (o1, o2) -\u0026gt; o1[0] - o2[0]);\t// 按照二维数组的第一个元素从小到大排序 Arrays.sort(array, (o1, o2) -\u0026gt; o1[1] - o2[1]);\t// 按照二维数组的第二个元素从小到大排序 打印：\nSystem.out.println(Arrays.toString(array)); 填满：\nint[] array = new int[]; int num; Arrays.fill(array, num);\t// array全部元素等于num String 创建字符串：\nString string = \u0026#34;java\u0026#34;; 指定位置的字符\nchar charAt3 = string.charAt(3);\t// charAt3 = \u0026#39;a\u0026#39; 字符串相等：\nString string1 = \u0026#34;abc\u0026#34;; String string2 = \u0026#34;abc\u0026#34;; string1.equals(string2); 字符串转整数：\nString string = \u0026#34;123\u0026#34;; int integer = Integer.parseInt(string); 字符串长度：\nint length = string.length(); 截取字符串：\nString sb = \u0026#34;abcdef\u0026#34;; String str = sb.substring(0, 1);\t// str = \u0026#34;a\u0026#34;; String str = sb.substring(1);\t// str = \u0026#34;bcdef\u0026#34;;\t如果只有一个参数则为beginIndex 字符的位置：\nString str = \u0026#34;abc\u0026#34;; int index = str.indexOf(b);\t// index = 1 字符串转字符数组：\nString str; char[] temp = str.toCharArray(); 字符串分割：\nString str = \u0026#34;hello world\u0026#34;; String[] word = str.split(\u0026#34; \u0026#34;);\t// word = [\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;] // 这里必须是字符串 // 如果有两个空格连在一起，会在数组中加入一个\u0026#34;\u0026#34;（空字符串） 将字符串数组合并为长字符串（中间插入）：\nString[] words = new String[]{\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;}; String str = String.join(\u0026#34; \u0026#34;, words); // str = \u0026#34;hello world\u0026#34;; 字符串替换：\nString str = \u0026#34;a! b\u0026#34;; str = str.replace(\u0026#34;!\u0026#34;, \u0026#34; \u0026#34;);\t// str = \u0026#34;a b\u0026#34;; // 字符或者字符串都可以替换 删除字符串头尾的空格：\nString str = \u0026#34; abc \u0026#34;; str.trim();\t// str = \u0026#34;abc\u0026#34; 字符串拼接：\nString str = \u0026#34;abc\u0026#34;; System.out.println(str + \u0026#34;def\u0026#34;);\t// 可以直接使用+ Stack 创建 stack：\nDeque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;Integer\u0026gt;(); 栈顶：\nstack.peek() 入栈：\nstack.push(); 出栈：\nstack.pop(); 栈是否为空：\nstack.isEmpty(); 栈的长度：\nstack.size(); ArrayList 创建列表：\nList\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(); List\u0026lt;Integer\u0026gt; array = new ArrayList\u0026lt;Integer\u0026gt;(Arrays.asList(1, 2, 3, 4));\t// 初始化值 添加元素：\narray.add(1);\t// List只能在末尾添加元素，在中间插入元素会导致额外的内存开销，可以选择使用LinkedList 指定位置的元素：\narray.get(0); 列表中是否存在某元素：\narray.contains(0); 删除列表元素：\narray.remove(0);\t// 删除array[0] array.remove(Integer.valueOf(0));\t// 删除元素0 列表大小：\narray.size(); 判断列表是否为空：\narray.isEmpty(); 清空列表：\narray.clear(); 升序排列：\narray.sort(Comparator.naturalOrder()); 降序排列：\narray.sort(Comparator.reverseOrder()); 修改值：\narray.set(int index, int value); 反转：\nCollections.reverse(array); HashMap 创建一个哈希映射：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;(); 存储键值对（修改键值对）：\nmap.put(key, value); 获取 key 的内容：\nmap.get(key); 如果不知道有没有内容：\nmap.getOrDefault(key, default); // 如果存在key，返回key的值 // 如果不存在key，返回default map.put(key, map.getOrDefault(key, 0) + 1); 查询是否存在 key：\nmap.containsKey(key); 遍历键值对：\n// 遍历key for (Integer key : map.keySet()) { } // 遍历value for (Integer value : map.values()) { } 是否为空：\nmap.isEmpty(); 删除Key：\nmap.remove(key); 大小：\nmap.size(); 排序：\nMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;Integer, Integer\u0026gt;();\t// 创建一个哈希映射 List\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt; mapList = new ArrayList\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;(map.entrySet());\t// 我们无法对HashMap排序，需要把HashMap转换为ArrayList再排序 Collections.sort(mapList, new Comparator\u0026lt;Map.Entry\u0026lt;Integer, Integer\u0026gt;\u0026gt;() { public int compare(Map.Entry\u0026lt;Integer, Integer\u0026gt; o1, Map.Entry\u0026lt;Integer, Integer\u0026gt; o2) { return (o2.getValue() - o1.getValue());\t// 按照值的大小，从大到小排序 } }); mapList.get(i).getKey();\t// 排序后第i个的键 mapList.get(i).getValue();\t// 排序后第i个的值 HashSet 创建哈希表：\nSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;Integer\u0026gt;(); 添加元素：\nset.add(); 判断元素是否存在：\nset.contains();\t// HashSet查找元素要优于ArrayList 删除元素：\nset.remove(); 清空：\nset.clear(); 遍历：\nfor (int temp : set) { ... } StringBuilder 创建 StringBuilder：\nStringBuilder sb = new StringBuilder(); 在末尾添加字符或字符串：\nsb.append(char); 在末尾删除字符：\nsb.deleteCharAt(sb.length() - 1); 长度：\nsb.length(); 转化为 String：\nsb.toString(); 取反：\nsb.reverse(); 插入：\nsb.insert(0, \u0026#34;abcd\u0026#34;);\t// 在第0个元素插入\u0026#34;abcd\u0026#34; 清空：\nsb.setLength(0); 取字符：\nsb.charAt(i); 修改位置的字符：\nsb.setCharAt(i); Queue 创建queue:\nQueue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;Integer\u0026gt;(); 加入元素：\nqueue.offer(1); 删除元素（先进先出）：\nqueue.poll(); 队首元素：\nqueue.peek(); 队列大小：\nqueue.size(); 是否为空：\nqueue.isEmpty(); 队列清空：\nqueue.clear(); Deque 创建Deque：\nDeque\u0026lt;Integer\u0026gt; deque = new ArrayDeque\u0026lt;Integer\u0026gt;(); 队尾添加元素：\ndeque.offerLast();\t// queue的用法 队首弹出元素：\ndeque.pollFirst();\t// queue的用法 取队首元素：\ndeque.peekFirst();\t// queue的用法 队首添加元素：\ndeque.offerFirst(); 队尾弹出元素：\ndeque.pollLast(); 取队尾元素：\ndeque.peekLast(); LinkedList 新建链表：\nLinkedList\u0026lt;Integer\u0026gt; link = new LinkedList\u0026lt;Integer\u0026gt;(); 头部插入：\nlink.addFirst(); 末尾插入：\nlink.addLast(); link.add(); 指定位置插入：\nlink.add(int index, int Ele); 清空：\nlink.clear(); 删除并返回第一个：\nlink.removeFirst(); 删除并返回最后一个：\nlink.removeLast(); 删除特定位置：\nlink.remove(int index); 删除特定元素：\nlink.remove(Object o); link.remove(Integer.valueOf(2)); 重设：\nlink.set(); 头部取值：\nlink.getFirst(); 尾部取值：\nlink.getLast(); 特定位置取值：\nlink.get(int index); 是否存在：\nlink.contains(int key); 遍历：\n// 不涉及元素增添或删除可以用for each for (String element : link) { } // 涉及到则需要使用迭代器 Iterator\u0026lt;String\u0026gt; iterator = link.iterator();\t// 初始化时指向哑节点 while (iterator.hasNext()) { String element = iterator.next(); } PriorityQueue 创建优先队列：\nPriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;Integer\u0026gt;(); // 如果不加Comparator默认为小根堆 // 即只有第一个元素是最小元素 插入元素：\nheap.offer(); 取堆顶：\nheap.peek(); 弹出堆顶：\nheap.poll(); 删除特定元素：\nheap.remove(); 堆大小：\nheap.size(); AtomicInteger 多线程中的integer，线程操作对其是原子性的，不会被其他线程打断。\n创建：\nAtomicInteger a = new AtomicInteger(0); 获取当前值：\nint value = a.get(); 设置值：\na.set(2); 先获取再设置：\nint oldValue = a.getAndSet(20); 先比较再设置：\nboolean updated = a.compareAndSet(20, 43); // 如果a == 20，则将a = 43，updated = true // 如果a != 20，则将a不更新，updated = false 加一，返回加一后的值：\nint incrementedValue = a.incrementAndGet(); 减一，返回减一后的值：\nint decrementedValue = a.decrementAndGet(); 互相转换 // int转String int i; String str = String.valueOf(i); // String转int String str; int i = Integer.parseInt(str); // char转int char ch; int i = ch - \u0026#39;0\u0026#39;; // int转char int i; char ch = (char) (i + \u0026#39;0\u0026#39;); // String转char[] String str; char[] ch = str.toCharArray(); // char[]转String char[] ch; String str = String.valueOf(ch); // char转String char ch = \u0026#39;a\u0026#39;; String str = ch + \u0026#34;\u0026#34;; // ArrayList转Integer[] List\u0026lt;Integer\u0026gt; list; Integer[] array = list.toArray(new Integer[list.size()]); // Integer[]转ArrayList Integer[] array; List\u0026lt;Integer\u0026gt; list = Arrays.asList(array); 坑 Math.ceil：\ndouble Math.ceil(double a);\t// 原函数 Math.ceil(24 / 23);\t// 1.0 Math.ceil(22 / 23);\t// 0.0 Math.ceil((double) 24 / 23);\t// 2.0 (int) Math.ceil((double) 24 / 23);\t// 2 Math.pow:\nMath.pow(10, 9);\t// 如果想求次方必须要用pow函数，返回double 10 ^ 9;\t// 这里表示的是亦或而不是次方 二维数组：\nint[][] a = new int[][] {{1, 2}, {3, 4}}; int[] b = a[1];\t// b = [3, 4] b[1] = 100; // a = [[1, 2], [3, 100]] ","permalink":"https://ymz-1.github.io/zh/blog/tech/java/","summary":"Character 判断是否为字母或数字： boolean res = Character.isLetterOrDigit(char); 转小写： char res = Character.toLowerCase(char); 下一个字符： \u0026#39;b\u0026#39; == (char) (\u0026#39;a\u0026#39; + 1); Integer 最大值最小值： int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; 比较相等： Integer a = 1; Integer b = 1; a == b; // true","title":"Java Cheat Sheet"},{"content":"char 转大小写：\nchar ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符：\n\u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值：\nint MAX = INT_MAX; int MIN = INT_MIN; array 创建数组：\nint array [4];\t// 如果不初始化则值随机 int array[] = {1,2,3,4}; int array[4] = {0};\t// {0, 0, 0, 0} // 注意只有0可以这样被初始化，其他的数是不行的 int array[4] = {1};\t// {1, 0, 0, 0}，只有第一个数被初始化为1，其他的还是默认值 引用：\narray[3]; 获取长度：\nsizeof(array) / sizeof(array[0]); 排序：\n#include \u0026lt;algorthm\u0026gt; int a[] = {5, 4, 3, 2, 1}; int n = sizeof(a) / sizeof(a[0]); // 升序 sort(a, a + n); // 降序 bool compare(int a, int b) { return a \u0026gt; b;\t// 若改为a \u0026lt; b则为升序 } sort(a, a + n, compare); string 创建字符串：\nstring s = \u0026#34;cpp\u0026#34;; 引用\ns[0]\t// s[0] = \u0026#39;c\u0026#39; 字符串相等：\nstring s1 = \u0026#34;abc\u0026#34;; string s2 = \u0026#34;abc\u0026#34;; s1.compare(s2); // 若s1小于s2返回-1 // 若相等返回0 // 若s1大于s2返回1 字符串长度：\nint n = s.size(); 字符串连接：\ns1.append(s2); 截取字符串：\nstring s = \u0026#34;abc\u0026#34;; string sub = s.substr(0, 1);\t// str = \u0026#34;a\u0026#34;; 字符的位置：\nstring s = \u0026#34;abc\u0026#34;; s.find(\u0026#39;a\u0026#39;);\t// 从前向后查找第一个出现的\u0026#39;a\u0026#39;的位置 s.rfind(\u0026#39;a\u0026#39;);\t// 从后往前查找第一个出现的\u0026#39;a\u0026#39;的位置 s.find_first_of(\u0026#34;abc\u0026#34;);\t// 从前往后查找第一次出现在\u0026#34;abc\u0026#34;中任意字符的位置 s.find_last_of(); s.find_first_not_of(); s.find_last_not_of(); // 如果没有查询到则返回： string::npos 插入字符串：\nstring s1 = \u0026#34;abc\u0026#34;; s1.insert(1, \u0026#34;ddd\u0026#34;);\t// s1 = \u0026#34;adddbc\u0026#34; 字符串交换：\ns1.swap(s2); 字符串替换：\nstring s = \u0026#34;a! b\u0026#34;; replace(s.begin(), s.end(), \u0026#39;!\u0026#39;, \u0026#39; \u0026#39;);\t// str = \u0026#34;a b\u0026#34;; 删除字符串头尾的空格：\nstring trim(string s) { if (s.empty()) { return s; } s.erase(0, s.find_first_not_of(\u0026#34; \u0026#34;)); s.erase(s.find_last_not_of(\u0026#34; \u0026#34;) + 1); return s; } 字符串修改：\nstring s = \u0026#34;apple\u0026#34;; s[0] = \u0026#39;b\u0026#39;; 字符串删除：\nstring s = \u0026#34;apple\u0026#34;; s.erase(bit, num);\t// bit表示开始的删除的位，num表示要删除的字符的个数 vector 定义vector：\n// 一维 vector\u0026lt;int\u0026gt; vec; vector\u0026lt;int\u0026gt; vec(3);\t// 默认值为0 // 利用数组初始化 int arr[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(begin(arr), end(arr)); // 二维 vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec(m, vector\u0026lt;int\u0026gt;(n));\t// 长为m，宽为n 排序：\nsort(vec.begin(), vec.end());\t// 升序 sort(vec.rbegin(), vec.end());\t// 降序 取栈顶：\nvec.back(); 判断是否存在：\nif (find(vec.begin(), vec.end(), key) != vec.end()) { // != 表示存在 } 删除元素：\nvec.erase(vec.begin() + index);\t// 删除第index个元素 判断是否为空：\nvec.empty(); 清空列表：\nvec.clear(); 反转：\nvec.reverse(vec.begin(), vec.end()); 二维排序：\nvector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; vec{{3, 4}, {1, 2}, {5, 6}}; // 按照第一列，升序排列 sort(vec.begin(), vec.end()); // 若不是，则需要写排序规则 bool compare(const vector\u0026lt;int\u0026gt; \u0026amp;a, const vector\u0026lt;int\u0026gt; \u0026amp;b) { return a[1] \u0026lt; b[1];\t// 按照第二列升序 } pair 创建：\npair\u0026lt;int, int\u0026gt; p; pair\u0026lt;int, int\u0026gt; p(p1, p2); make_pair(p1, p2); 取值：\np1.first;\t// 第一个元素 p1.second;\t// 第二个元素 pair作为函数返回值：\nstd::pair\u0026lt;std::string, std::int\u0026gt; getPerson() { return std::make_pair(\u0026#34;ymz-1\u0026#34;, 1); } std::tie(p1, p2) = getPerson(); unordered_map 创建一个哈希映射：\n#include \u0026lt;unordered_map\u0026gt; unordered_map \u0026lt;int, int\u0026gt; map; 存储键值对（修改键值对）：\nmap.insert(pair\u0026lt;int, int\u0026gt;(key, value)); map[key] = value;\t// 这种更简单 获取 key 的内容：\nmap[key]; 查询是否存在 key：\nmap.count(key);\t// 如果存在，返回1，不存在则返回0 if ((auto iter = map.find(key)) != map.end());\t// 存在则括号内为真 // iter的数据类型为 unordered_map\u0026lt;int, int\u0026gt;::iterator if (map[key] == 0)\t// 这种最简单 遍历键值对：\nfor (auto i = map.begin(); i != map.end(); i++) { // key: i-\u0026gt;first // value: i-\u0026gt;second } 是否为空：\nmap.empty(); 删除Key：\nmap.erase(key); map的大小：\nmap.size(); unordered_set 遍历：\nfor (auto i = set.begin(); i != set.end(); i++) { cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; endl; } queue 创建queue:\nqueue\u0026lt;int\u0026gt; q; 加入元素：\nq.push(1); 删除队首元素：\nq.pop();\t// 这个没有返回值 队首元素：\nq.front(); 队列大小：\nq.size(); 是否为空：\nq.empty(); 互相转换 // int转string int i; string str = to_string(i); // string转int String str; int i = stoi(str); // char转int char ch; int i = ch - \u0026#39;0\u0026#39;; // int转char int i; char ch = i + \u0026#39;0\u0026#39;; // char[]转int char s[] = \u0026#34;111\u0026#34;; int i = atoi(s); // int转char[] int i = 111; char ch[100]; itoa(i, ch, 10); // 第一个参数为待转化的整数 // 第二个参数为输出的字符串数组 // 第三个参数为进制，范围为2 - 36 // String转char[] string str; char *ch = (char *)str.data(); // char[]转String char ch[] = \u0026#34;abcd\u0026#34;; string str(ch); // char转String char ch = \u0026#39;a\u0026#39;; string str(1, ch); // int[]转vector int a[] = {1, 2, 3}; vector\u0026lt;int\u0026gt; vec(a, a + sizeof(a) / sizeof(int)); // vector转int[] vector\u0026lt;int\u0026gt; vec{1, 2, 3}; int i[vec.size()]; memcpy(i, \u0026amp;vec[0], vec.size() * sizeof(vec[0])); ","permalink":"https://ymz-1.github.io/zh/blog/tech/cpp/","summary":"char 转大小写： char ch = \u0026#39;a\u0026#39;; ch = (char) toupper(ch); ch = (char) tolower(ch); 下一个字符： \u0026#39;b\u0026#39; == (\u0026#39;a\u0026#39; + 1); int 最大值最小值： int MAX = INT_MAX; int MIN = INT_MIN; array 创建数组： int array [4]; // 如果不初始化则值随机 int array[] = {1,2,3,4}; int","title":"Cpp Cheat Sheet"},{"content":"Aug 2021, Bank of China 我的第一张信用卡是出国前和我爹一起去中国银行办的卓隽，我用我爹的副卡，不太清楚额度是多少。我只是刚到加拿大的前几天用这张卡，出了隔离之后办了Scotiabank就不再使用了，以后如果回国买水果产品分期的话说不定也会偶尔用用，反正我爹还钱。\n这张卡无年费，开卡奖励不清楚，返现不清楚，但是摸起来比加拿大的银行卡要厚好多，质感好一些，不知道是不是心理作用。据说这张卡现在有了CAD直接结算的，这样的话用起来会更方便。\nSep 2021, Scotiabank Scene+ 由于办学签来加拿大走的是SDS通道需要买个$10000的GIC，光大银行离家近，我就直接办的光大银行的GIC。光大银行对接的是Scotiabank，来到加拿大以后找了家Scotiabank的branch就给我开了checking account和信用卡，额度是$500。由于额度太少了我当时买好多东西都是先提前往里充钱，再刷卡消费，把信用卡花成了prepaid card。因为这是我第一张加拿大信用卡，所以也不会关卡。\n这张卡无年费，开卡送5000 Scene+积分，Sobeys旗下的超市，双立人，Cineplex都是2x积分，其他消费1x积分，之前换电影票好像是1250分，后来变成总价格 * 100 Scene+积分。最开始也没研究怎么薅羊毛，所以我在毕业之前一直在用这张卡。\nJan 2023, BMO Cashback 这个时候找到工作，就开始研究怎么薅羊毛了，最开始申请的是这张BMO的买菜卡，额度$1000。由于一开始只想找个无年费且返现高的就申请了这张，确实这张卡在无年费的里面算比较好的了。\n这张卡无年费，好像也没有什么开卡奖励（好像是前1个月还是3个月买菜10%返现），买菜3%返现（每月$500的cap），流媒体账单1%返现，其他消费0.5%返现，Mastercard应该会把沃尔玛算作Grocery因此也有3%（待考证）。最主要的是由于22年趁着黑五开了Costco，当时一直没有Mastercard来刷Costco，这下终于可以在Costco消费了。这张卡用了半年，基本只有买菜在用，返了$300多，因此还是挺不错的。\nMar 2023, CIBC Costco 很快我就发现只有买菜返现可不行，还得再申请一张卡用来对应吃饭的返现，于是开始研究无年费饭卡。本来想申请Simplii是4%返现，但是听说非PR不太好下卡，最后还是选择了Costco的信用卡，刚开始给我的额度是$3000，后来他们给我提升到$6000。\n这张卡无年费，但是必须要有Costco会员，吃饭3%返现，Costco加油3%返现，其他加油站2%返现，Costco网站消费2%返现，但是网站价格要更贵一些，其他消费1%返现。这张卡也用了半年，感觉返现速度比较慢，半年多也才返了$300。打算把Costco停掉之后转到CIBC的其他卡。\nMay 2023, Simplii 这张卡是一张debit card，绑定工资可以拿到$400，refer能再拿$50。无年费，无限次email transfer还是很爽的，可以去CIBC的ATM取现金，缺点就是一天取最多$200。\nAug 2023, Triangle MC 这段时间被SportChek店员忽悠着办了一张Triangle的卡。他应该是按照惯例问我要不要办这张卡，我当时还对信用卡研究没有这么深，以为这是那张带着免费拖车的卡，于是稀里糊涂就同意了，这店员一听我同意了也很懵逼，可能是被拒绝惯了。正当我准备拿出自己的信用卡付款的时候店员说不用了，会把消费记到这张新信用卡身上。我问会不会被hard pull，他说可以不激活卡，这样就只会soft pull一下，我又问那我不激活怎么给这张信用卡付款，他说在你checking账户加入payee就可以了，最后我说好吧就这样办了这张卡。后来还是没发现该怎么不激活就还款，也懒得打电话问，干脆就激活了，当时也没管有没有hard pull。总结永远不要办沃尔玛，SportChek这种店员老大妈过来围着问你要不要办的卡。\n其实这张卡也挺不错的，无年费，Triangle加油直接每升便宜5分钱，Canadian Tire旗下包括SportChek都是4%返现。后边办了Cobalt之后基本上油价便宜的时候会去Canadian Tire加油刷这个卡，油价贵的时候去别的地方加油刷Cobalt，所有的返现都会转化成CT Money然后在Canadian Tire旗下的商店使用。\n不过对于加油问题我刚算了一下，假设油价为a，加油体积为b，Triangle真实的加油消费为：(a - 0.04) * b = ab - 0.04b，Cobalt真实加油消费为：ab * (1 - 0.016 * 2) = 0.968ab。也就是说当油价低于1.25的时候Triangle才比Cobalt划算，我来加拿大之后还没有遇见过这么便宜的油价，那这张MC真是屁用没有了，等着买了房子转成黑卡吧。\n黑卡WEMC除了这张普通卡有的服务以外，还有免费拖车和地税服务。不过我也暂时也用不上，等到时候再换卡就可以了。不过所有的WEMC信用卡都有免费的Boingo WiFi，之前在国泰航空上看到过这个，等什么时候有了张WEMC上飞机的时候试试。黑卡还有一点就是长时间不用的话就会自己关卡，所以得等有了房子之后用来交地税才能保证经常用。\nOct 2023, EQ Card 这张卡是一张prepaid Mastercard，得预先充值才能花钱。我特别喜欢这张卡，觉得颜值超高，而且这张卡的包装方式很独特，是像个抽屉一样抽出来的。\n这张卡在ATM取款是不收手续费的，更重要的是，它花外币也不收2.5%的手续费，而且还有0.5%的返现，我把ChatGPT，EZPass这种美元结算的都绑定在这张卡上。因为平时花美元也不多，可能也就是去旅游的话会花，所以也没有单独去申请专门的外币卡。\nOct 2023, AMEX Cobalt 由于之前一直只想办无年费的信用卡，且觉得加拿大AMEX接受率不高，再加上觉得使用PPP过于麻烦，于是并没有考虑办AMEX的卡。后来在朋友的忽悠下，正好那段时间Cobalt refer别人奖励翻倍，于是我也办了张Cobalt，也幸亏如此，如果再晚一个周开卡的话，Cobalt奖励就从之前的30000MR变成了15000MR，这羊毛又薅到了。\n这张卡月费$12.99，相当于年费$155.88，开卡奖励每月花$500返2500MR持续12个月（现在变成了每月花$750返1250MR持续12个月）。吃饭（美国的餐厅也可以），买菜（建兴超市也可以刷）都是5x积分，流媒体（包括Apple Music）3x积分，酒店Airbnb机票加油 2x积分，其他消费1x积分，refer一个人送5000MR。我开卡两个月就拿了40000MR简直是太爽了（1MR可以看作$0.016）。所有的MR积分都可以1:1地转化为Areoplan积分，刷几个月一张回国机票就出来了。\n经过了几个月的记账之后发现，平时消费最多的地方不在买菜和外出吃饭而在于其他消费。好不容易办一张有年费的信用卡那可得薅个痛快，于是我开始买Paypower Prepaid Mastercard (PPP)。PPP也算是老羊毛了，比较安全，在超市里搭一根香蕉基本不会被FR。\n之前算过买reloadable的PPP和non-reloadable PPP的区别，假设我一个人，每个月买$2500的PPP。\nNon-reloadable:\nNon-reloadable的算法就很简单了，每张卡$9.95+tax就完了，一次买$500，不过这样的话我1个月最多也就买2张PPP，能5x积分的就直接拿Cobalt刷了。\nCOBALT_MONTHLY_FEE = 12.99 AMEX_VALUE = 0.016 # Let 1MR = $0.016 TAX_RATE = 1.13 PPP_NONRELOADABLE = 9.95 * TAX_RATE PPP_PER_MONTH = 2 class NONRELOAD: def __init__(self): self.cost = COBALT_MONTHLY_FEE + PPP_PER_MONTH * PPP_NONRELOADABLE self.cashback = round(500 + PPP_NONRELOADABLE) * 5 * PPP_PER_MONTH * AMEX_VALUE self.profit = self.cashback - self.cost if __name__ == \u0026#34;__main__\u0026#34;: nonreload = NONRELOAD() print(f\u0026#39;Non-reload ppp cost\u0026#39;.ljust(30) + f\u0026#39;= {nonreload.cost:.2f}\u0026#39;) print(f\u0026#39;Non-reload ppp cashback\u0026#39;.ljust(30) + f\u0026#39;= {nonreload.cashback:.2f}\u0026#39;) print(f\u0026#39;Non-reload ppp profit\u0026#39;.ljust(30) + f\u0026#39;= {nonreload.profit:.2f}\u0026#39;) 按照每个月2张PPP算下来的返现是：\nNon-reload ppp cost = 35.48 Non-reload ppp cashback = 81.76 Non-reload ppp profit = 46.28 剩余的$2500 - $9.95 * 1.13 * 2 - $500 * 2 = $1477 肯定都是5x积分了，当然我是穷逼肯定不会都花完，就当$1000来算，这样最终的返现为：$1000 * 5 * 0.016 + $46.28 = $126.28。\nNon-reloadable的缺点就是每次只能买$500的卡，花完了就得再去超市买，所以如果想买超过$500的商品就比较麻烦了，可以搭配着gift card来使用。另外一个缺点就是最后剩下点钱不知道该怎么办了，本超级社恐肯定是不会厚着脸皮让店员separate to two bills的，我就都拿来充Presto卡了。\nReloadable:\nReloadable由于需要耗费太多精力了，而且需要找菜店店员帮我充值，所以本超级社恐一直懒得搞，不过要是有人知道Richmond Hill或者Markham哪里可以买reloadable的ppp也麻烦告诉我一下😁。\n基本原理就是这样的，如果有一张其他的高返现的信用卡，比如说Rogers Bank新出的那张红卡，（不太清楚PPP能不能给这张卡还账单毕竟是张新卡，只是拿来举个例子）。0年费，而且只要是Rogers或者Fido用户都可以3%返现，那就可以平时的消费全部刷红卡，然后去超市用Cobalt买PPP用来还红卡的账单。\n当然PPP也是有一定费用的，PPP每次最多充$500，总金额最高是$2500，reload手续费是$6.95，月费是$4.95，每次付账单手续费是$1.95。付账单也有金额限制，每24小时最多$1000，每7天最多$2500，每30天最多$5000。\n假设我1个月花$2000，就需要买4张PPP来还账单：\nimport math COBALT_MONTHLY_FEE = 12.99 AMEX_VALUE = 0.016 # Let 1MR = $0.016 TAX_RATE = 1.13 PPP_NONRELOADABLE = 9.95 * TAX_RATE PPP_PER_MONTH = 4 PPP_RELOAD_FEE = 6.95 PPP_BILL_FEE = 1.95 MONTHLY_COST = 2000 # How much do I spend per month PPP_BILL_AMOUNT = 1000 # How much PPP can pay bill at a time PPP_MONTHLY_FEE = 4.95 ROGERS_CASHBACK_RATE = 0.03 class RELOAD: def __init__(self): self.reload_cost = PPP_PER_MONTH * PPP_RELOAD_FEE self.card_cost = COBALT_MONTHLY_FEE + PPP_MONTHLY_FEE self.bill_cost = math.ceil(MONTHLY_COST / PPP_BILL_AMOUNT) * PPP_BILL_FEE self.rogers_cashback = MONTHLY_COST * ROGERS_CASHBACK_RATE self.cobalt_cashback = round(500 + PPP_RELOAD_FEE) * 5 * PPP_PER_MONTH * AMEX_VALUE self.cost = self.reload_cost + self.card_cost + self.bill_cost self.cashback = self.rogers_cashback + self.cobalt_cashback self.profit = self.cashback - self.cost if __name__ == \u0026#34;__main__\u0026#34;: reload = RELOAD() print(f\u0026#39;Reload ppp total cost\u0026#39;.ljust(30) + f\u0026#39;= {reload.cost:.2f}\u0026#39;) print(f\u0026#39;Reload ppp total cashback\u0026#39;.ljust(30) + f\u0026#39;= {reload.cashback:.2f}\u0026#39;) print(f\u0026#39;Reload ppp profit\u0026#39;.ljust(30) + f\u0026#39;= {reload.profit:.2f}\u0026#39;) 所以同样是花$2000，这样最终的返现是：\nReload ppp cost = 49.64 Reload ppp cashback = 222.24 Reload ppp profit = 172.60 这样每个月比non-reloadable多不到$50，也算是还行吧。\nJan 2024, TD Areoplan 最近薅了把TD的羊毛，开checking account绑定工资再还一次账单，能拿$400，新移民能waive掉第一年的年费。开saving账户存$5000能拿$100，存$10000拿$200。开TSFA，FHSA，RRSP 3个账户中的1个存$5000拿$150，3个中的2个各存$5000拿$350。信用卡本来想申请黑色的Areoplan卡结果被拒了说我不是PR，于是打算申请白色的，开卡消费一次送10000Areoplan积分，90天内消费$1000还能再拿10000Areoplan积分，第一年都是免年费的。算下来总共是$750的cash，20000Areoplan积分，免去了$292.4的月费，这些羊毛马上就要过期了但是我都薅到了嘿嘿嘿。\n由于这张卡我就是打算薅开户奖励的，因此也不怎么在意返点。它年费是$89，买菜，加油，Air Canada消费1x积分，其他消费$1.5返1Areoplan积分，在星巴克消费可以多返50%Areoplan积分（也就是1.5x积分）。基本上都没有Cobalt好。\n黑卡的话是消费返10000Areoplan积分，半年之内消费$5000返25000Areoplan积分（Jan 3, 2024之后Approve的卡是20000），一年之内消费$7500返15000Areoplan积分（Jan 3, 2024之后Approve的卡是10000），纯开户奖励的话还真没有白卡好，而且必须要PR才行。\nFeb 2024, Rogers WEMC Rogers刚把自家的WEMC给升级了，于是马上办了这张卡，GCR给返了$50。所有消费2%返现，Fido, Rogers用户可以多redeem 50%也就是3%返现，这些跟Rogers Mastercard都一样。多出来的是美元的3%返现，等4月份充个ChatGPT会员看看是不是能4.5%的返现。不过这张卡对我来说也就是WEMC自带的Boingo可能会有点用，毕竟有Cobalt + PPP平时用的可能不怎么多，但不可否认是张很不错的抽屉卡，之后会留着PPP不够用了应急用，或者买一件超过500刀的东西用，或者刷美元时候用。\nMay 2024，AMEX Marriott 已经有计划5月份申请了AMEX Marriott Bonvoy了，目前是史高奖励，3个月内花$3000送65000万豪分，开卡前6个月在汽油和旅游上的消费$1额外返3点万豪积分，GCR返~~$75~~~~$60~~（又变成$75了）（80000 + $75~~$60~~$75），refer的话能多5000积分（85000），按照1万豪分0.9cents来看的话还是GCR更划算一点。\n这个卡是个抽屉卡，年费$120，第二年开始每年送一张房券，在万豪消费$1返5积分，但是不免FX fee比较傻逼。\n","permalink":"https://ymz-1.github.io/zh/blog/life/credit-card/","summary":"Aug 2021, Bank of China 我的第一张信用卡是出国前和我爹一起去中国银行办的卓隽，我用我爹的副卡，不太清楚额度是多少。我只是刚到加拿大的前几天用这张卡，出了隔","title":"加拿大🇨🇦信用卡薅羊毛心得"},{"content":" Dec 25, 2022，硕士毕业 Jan 3, 2023，收到毕业信 Apr 27, 2023，收到CELPIP成绩，入池，其实毕业之前就该考出来的，没必要等着PGWP下来再申请省提名，白浪费了半年多 Jun 6, 2023，被捞，当天提交申请 Jun 27, 2023，补交材料 Jun 28, 2023，收到DIP Jul 25, 2023，收到省提名信，这里估摸着差不多了提前把无犯罪证明，出生证明，身份证，户口本公正或者翻译了，还能再省点时间（身份证和户口本是Optional） Aug 1, 2023，提交联邦申请 Dec 1, 2023，收到AOR和指纹信，成功link到IRCC Dec 12, 2023，收到PAL Dec 14, 2023，上午录指纹的时候发现邮箱里有体检信，提醒一下如果有办学签时候的体检证明一块交了，到时候可以waive掉，我这里找不到了只能再做一次体检，验尿抽血胸片，怒花270刀保险还不报销😭，由于可以walk in下午我直接去做了体检 Feb 14, 2024，被要求提交简历，看来要被安调 Feb 15, 2024，tracker上F12出现17 security被安调了，这一时半会出不了安省了，怪你电太牛逼吧 未完待续\u0026hellip;希望早点收到枫叶卡，早点入籍了好让我南下赚钱 ","permalink":"https://ymz-1.github.io/zh/blog/life/pr/","summary":"Dec 25, 2022，硕士毕业 Jan 3, 2023，收到毕业信 Apr 27, 2023，收到CELPIP成绩，入池，其实毕业之前就该考出来的，没必要等着PGWP下来再申","title":"OINP移民加拿大🇨🇦时间线"},{"content":"\rKunyang\u0026#39;s Blog\rA Hello World Printer\rSulv’s Blog\r记录技术、阅读、生活的博客\r友链格式：\nname=\u0026#34;ymz-1\u0026#39;s Blog\u0026#34; url=\u0026#34;https://ymz-1.github.io/zh\u0026#34; logo=\u0026#34;https://ymz-1.github.io/Avatar.png\u0026#34; word=\u0026#34;A Hello World Printer\u0026#34; ","permalink":"https://ymz-1.github.io/zh/links/","summary":"Kunyang\u0026#39;s Blog A Hello World Printer Sulv’s Blog 记录技术、阅读、生活的博客 友链格式： name=\u0026#34;ymz-1\u0026#39;s Blog\u0026#34; url=\u0026#34;https://ymz-1.github.io/zh\u0026#34; logo=\u0026#34;https://ymz-1.github.io/Avatar.png\u0026#34; word=\u0026#34;A Hello World Printer\u0026#34;","title":"友链 🤝"},{"content":"👉️填写QQ邮箱可以自动获取QQ头像哦\n","permalink":"https://ymz-1.github.io/zh/comment/comments/","summary":"👉️填写QQ邮箱可以自动获取QQ头像哦","title":"留言板 📋"},{"content":"\n","permalink":"https://ymz-1.github.io/zh/blog/life/music/","summary":"","title":"最近爱听"},{"content":" 研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript\nGitHub (前端仓库): https://github.com/ymz-1/money-management.git\nGitHub (后端仓库): https://github.com/ymz-1/money-back.git\n这是一个帮助我们记录每天生活花费的手机App。 前端基于React.js框架，后端基于Express.js框架，数据库基于MongoDB。 可以添加，编辑和删除每一条消费记录，并且App会生成一些折线图和饼图帮助我们分析近期的消费。 还可以直观地看到哪一种消费花了多少钱，以及不同种类的消费的排序。 交通监视系统 2021年9月 至 2021年12月，Python / C++\nGitHub: https://github.com/ymz-1/Traffic.git\n这个项目帮助当地警察局在道路交叉口安装最少的摄像头，但是获得最大的监控覆盖面积。这是一个顶点覆盖问题，我们利用CNF-SAT来对这个问题进行优化。 使用Python生成一张包含城市交通细节的地图(道路和十字路口)，然后尝试使用迪杰斯特拉算法在城市中找到最短路径，最后，我们利用CNF-SAT模拟安装摄像头是否能覆盖城市所有街道，解决顶点覆盖问题。 该项目实现了多线程和并行处理，以更高效地运行。 我的个人网站 2021年8月 至 今，HTML / CSS / JavaScript\nGitHub: https://github.com/ymz-1/ymz-1.github.io.git\n这个项目是基于Hugo的PaperMod主题。 本科项目 基于深度学习的行人重识别系统 2020年9月 至 2021年6月，Python\nGitHub: https://github.com/ymz-1/ReID-deep-learning.git\n本项目是基于深度学习方法的行人重识别系统，所使用的框架是PyTorch。 我们利用Market-1501数据集去训练模型，然后利用这个数据集和我们自创的UESTC Re-ID数据集去测试模型。 本项目的深度学习模型为ResNet-50，损失函数为TriHard损失。 对于Market-1501数据集的mAP指标达到58.8%，rank@1指标达到76.3%。 信道分配系统 2021年4月 至 2021年5月，MATLAB\nGitHub: https://github.com/ymz-1/Channels.git\n这是一个关于信道分配问题的项目，项目背景为在医院中，将最高信噪比的信道分配给最需要的人（例如病人），而将普通人分配给病人的干扰信道（信噪比低）。 我们提出了4种算法去实现这个问题。 Webots机器人 2020年2月 至 2020年6月，C++\nGitHub: https://github.com/ymz-1/TDPS-2020-UESTC-Glasgow.git\nBilibili: https://www.bilibili.com/video/BV1Rp4y1S7o3?from=search\u0026amp;seid=72774621551842110\n\u003c!DOCTYPE HTML\u003e\r这是一个基于Webots的项目。 我们在Webots软件中设计了一个智能小车和完成任务需要的场地，我们为小车安装了惯性导航模块，LIDAR模块和摄像头模块使得小车可以完成巡线，姿态解算，颜色识别等任务。 基于FPGA的波形发生器 2019年9月 至 2019年12月, Verilog\nGitHub: https://github.com/ymz-1/wave-generator.git\n利用FPGA (Xilinx xc7a35tftg256)来生成正弦波，三角波和方波。 波的频率可调，从0 - 255Hz，并由8位USART控制。 利用4个拨码开关来控制振幅，从0 - 1V，分辨率为0.1V。 利用2个拨码开关来选择波形。 输出结果可通过VGA显示，可显示相应波形的图像信息和频率、幅值。 一个RISC架构的CPU 2018年2月 至 2018年6月, Verilog\nGitHub: https://github.com/ymz-1/CPU.git\n使用Quartus II软件实现RISC CPU，使其能够进行加、减、乘、除操作。 CPU的设计包含数据路径模块设计（ALU，寄存器和PC），控制单元设计（状态转换和IR）以及这两个模块之间的通信（CPU的集成）。 ","permalink":"https://ymz-1.github.io/zh/projects/","summary":"研究生项目 Turbo Wallet - 记账软件 2022年1月 至 2022年3月，JavaScript GitHub (前端仓库): https://github.com/ymz-1/money-management.git GitHub (后端仓库): https://github.com/ymz-1/money-back.git 这是一个帮助我们记录每天生活","title":"项目 👨‍💻"},{"content":"class Me: def __init__(self): self.name = \u0026#34;Kunyang Xie\u0026#34; self.prefer_name = \u0026#34;Yemz\u0026#34; self.born_year = 1999 self.MBTI = \u0026#34;ISTJ\u0026#34; self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34; self.curr_location = \u0026#34;Richmond Hill, ON, CA\u0026#34; self.grad_school = \u0026#34;uWaterloo\u0026#34; self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34; ","permalink":"https://ymz-1.github.io/zh/about/","summary":"class Me: def __init__(self): self.name = \u0026#34;Kunyang Xie\u0026#34; self.prefer_name = \u0026#34;Yemz\u0026#34; self.born_year = 1999 self.MBTI = \u0026#34;ISTJ\u0026#34; self.hometown = \u0026#34;Weifang, Shandong, CN\u0026#34; self.curr_location = \u0026#34;Richmond Hill, ON, CA\u0026#34; self.grad_school = \u0026#34;uWaterloo\u0026#34; self.undergrad_school = \u0026#34;UESTC, UofG\u0026#34;","title":"关于我 👋"}]
